#include <stdio.h>
#ifndef NULL
#define NULL    ((void *)0)
#endif
typedef unsigned char uint8;
typedef unsigned int uint16;
typedef unsigned long uint32;

typedef char int8;
typedef short int int16;
typedef int int32;
typedef unsigned char BYTE;
typedef char sint8;
enum _BOM
{
    TYPE_UNICODE = 0,
    TYPE_UNICODE_BIG,
    TYPE_UTF_8
};
FILE *fRead, *fWrite;
#define DEBUG_EBU 0
uint8 PutHex8(uint8 val, uint8 type, uint8* Flag)
{
    uint8 tmp;
    uint8 StrBuf[4] = {0x5c, 'x', 0, 0};
    if((val >= 'a' && val <= 'f') || (val >= 'A' && val <= 'F'))
    {
        if(*Flag == 0)
        {
            return 1;
        }
    }
    else if(type == 3)
        return 1;
    *Flag = 1;
    tmp = ((val >> 4) & 0x0F);
    if (tmp < 10)
    {
        tmp += '0';
    }
    else
    {
        tmp += ('A' - 10);
    }
    StrBuf[2] = tmp;
    tmp = (val & 0x0F);
    if (tmp < 10)
    {
        tmp += '0';
    }
    else
    {
        tmp += ('A' - 10);
    }
    StrBuf[3] = tmp;
    for(tmp = 0; tmp < 4; tmp++)
    {
        if(type == TYPE_UNICODE)
        {
            fputc(StrBuf[tmp], fWrite);
            fputc(0, fWrite);
        }
        else if(type == TYPE_UNICODE_BIG)
        {
            fputc(0, fWrite);
            fputc(StrBuf[tmp], fWrite);
        }
        else
        {
            fputc(StrBuf[tmp], fWrite);
        }
    }
    return 0;
}
const uint16  EBULatinBased2UnicodeTable[] =
{
    0x0000, 0x0118, 0x012E, 0x0172, 0x0102, 0x0116, 0x010E, 0x0218, 0x021A, 0x010A, 0x0000, 0x000B, 0x0120, 0x0139, 0x017B, 0x0143,  //0x00 ~ 0x0F
    0x0105, 0x0119, 0x012F, 0x0173, 0x0103, 0x0117, 0x010F, 0x0219, 0x021B, 0x010B, 0x0147, 0x011A, 0x0121, 0x013A, 0x017C, 0x001F,  //0x10 ~ 0x1F
    0x0000, 0x0000, 0x0000, 0x0000, 0x0142, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  //0x20 ~ 0x2F
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  //0x30 ~ 0x3F
    0x0000, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  //0x40 ~ 0x4F
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x016E, 0x0000, 0x0141, 0x0000,  //0x50 ~ 0x5F
    0x0104, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,  //0x60 ~ 0x6F
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00AB, 0x016F, 0x00BB, 0x013D, 0x0126,  //0x70 ~ 0x7F
    0x00E1, 0x00E0, 0x00E9, 0x00E8, 0x00ED, 0x00EC, 0x00F3, 0x00F2, 0x00FA, 0x00F9, 0x00D1, 0x00C7, 0x015E, 0x00DF, 0x00A1, 0x0178,  //0x80 ~ 0x8F
    0x00E2, 0x00E4, 0x00EA, 0x00EB, 0x00EE, 0x00EF, 0x00F4, 0x00F6, 0x00FB, 0x00FC, 0x00F1, 0x00E7, 0x015F, 0x011F, 0x0131, 0x00FF,  //0x90 ~ 0x9F
    0x0136, 0x0145, 0x00A9, 0x0122, 0x011E, 0x011B, 0x0148, 0x0151, 0x0150, 0x20AC, 0x00A3, 0x0024, 0x0100, 0x0112, 0x012A, 0x016A,  //0xA0 ~ 0xAF
    0x0137, 0x0146, 0x013B, 0x0123, 0x013C, 0x0130, 0x0144, 0x0171, 0x0170, 0x00BF, 0x013E, 0x00B0, 0x0101, 0x0113, 0x012B, 0x016B,  //0xB0 ~ 0xBF
    0x00C1, 0x00C0, 0x00C9, 0x00C8, 0x00CD, 0x00CC, 0x00D3, 0x00D2, 0x00DA, 0x00D9, 0x0158, 0x010C, 0x0160, 0x017D, 0x00D0, 0x013F,  //0xC0 ~ 0xCF
    0x00C2, 0x00C4, 0x00CA, 0x00CB, 0x00CE, 0x00CF, 0x00D4, 0x00D6, 0x00DB, 0x00DC, 0x0159, 0x010D, 0x0161, 0x017E, 0x0111, 0x0140,  //0xD0 ~ 0xDF
    0x00C3, 0x00C5, 0x00C6, 0x0152, 0x0177, 0x00DD, 0x00D5, 0x00D8, 0x00DE, 0x014A, 0x0154, 0x0106, 0x015A, 0x0179, 0x0164, 0x00F0,  //0xE0 ~ 0xEF
    0x00E3, 0x00E5, 0x00E6, 0x0153, 0x0175, 0x00FD, 0x00F5, 0x00F8, 0x00FE, 0x014B, 0x0155, 0x0107, 0x015B, 0x017A, 0x0165, 0x0127,  //0xF0 ~ 0xFF
};
const uint16 Utf8_Table[] = {
  0x0000, 0xc498, 0xc4ae, 0xc5b2, 0xc482, 0xc496, 0xc48e, 0xc898, 0xc89a, 0xc48a, 0x0000, 0x0000, 0xc4a0, 0xc4b9, 0xc5bb, 0xc583, /*0x00 ~ 0x0F*/
  0xc485, 0xc499, 0xc4af, 0xc5b3, 0xc483, 0xc497, 0xc48f, 0xc899, 0xc89b, 0xc48b, 0xc587, 0xc49a, 0xc4a1, 0xc4ba, 0xc5bc, 0x0000, /*0x10 ~ 0x1F*/
  0x0000, 0x0000, 0x0000, 0x0000, 0xc582, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /*0x20 ~ 0x2F*/
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /*0x30 ~ 0x3F*/
  0x0000, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /*0x40 ~ 0x4F*/
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xc581, 0x0000, /*0x50 ~ 0x5F*/
  0xc484, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /*0x60 ~ 0x6F*/
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xc2ab, 0xc5af, 0xc2bb, 0xc4bd, 0xc4a6, /*0x70 ~ 0x7F*/
  0xc3a1, 0xc3a0, 0xc3a9, 0xc3a8, 0xc3ad, 0xc3ac, 0xc3b3, 0xc3b2, 0xc3ba, 0xc3b9, 0xc391, 0xc387, 0xc59e, 0xc39f, 0xc2a1, 0xc5b8, /*0x80 ~ 0x8F*/
  0xc3a2, 0xc3a4, 0xc3aa, 0xc3ab, 0xc3ae, 0xc3af, 0xc3b4, 0xc3b6, 0xc3bb, 0xc3bc, 0xc3b1, 0xc3a7, 0xc59f, 0xc49f, 0xc4b1, 0xc3bf, /*0x90 ~ 0x9F*/
  0xc4b6, 0xc585, 0xc2a9, 0xc4a2, 0xc49e, 0xc49b, 0xc588, 0xc591, 0xc590, 0xe282, 0xc2a3, 0x0000, 0xc480, 0xc492, 0xc4aa, 0xc5aa, /*0xA0 ~ 0xAF*/
  0xc4b7, 0xc586, 0xc4bb, 0xc4a3, 0xc4bc, 0xc4b0, 0xc584, 0xc5b1, 0xc5b0, 0xc2bf, 0xc4be, 0xc2b0, 0xc481, 0xc493, 0xc4ab, 0xc5ab, /*0xB0 ~ 0xBF*/
  0xc381, 0xc380, 0xc389, 0xc388, 0xc38d, 0xc38c, 0xc393, 0xc392, 0xc39a, 0xc399, 0xc598, 0xc48c, 0xc5a0, 0xc5bd, 0xc390, 0xc4bf, /*0xC0 ~ 0xCF*/
  0xc382, 0xc384, 0xc38a, 0xc38b, 0xc38e, 0xc38f, 0xc394, 0xc396, 0xc39b, 0xc39c, 0xc599, 0xc48d, 0xc5a1, 0xc5be, 0xc491, 0xc580, /*0xD0 ~ 0xDF*/
  0xc383, 0xc385, 0xc386, 0xc592, 0xc5b7, 0xc39d, 0xc395, 0xc398, 0xc39e, 0xc58a, 0xc594, 0xc486, 0xc59a, 0xc5b9, 0xc5a4, 0xc3b0, /*0xE0 ~ 0xEF*/
  0xc3a3, 0xc3a5, 0xc3a6, 0xc593, 0xc5b5, 0xc3bd, 0xc3b5, 0xc3b8, 0xc3be, 0xc58b, 0xc595, 0xc487, 0xc59b, 0xc5ba, 0xc5a5, 0xc4a7, /*0xF0 ~ 0xFF*/

};

int main(void)
{
    unsigned int k;
    unsigned int j;
    unsigned char ch;
    unsigned long cnt = 0;
    int CodeType;
    uint8 TempBuf[3] = {0};
    uint8 Flag = 0;
    //printf("\nDelete such as #if #ifdef 1 or 0\n");
    //scanf("%c",&k);
        fRead = fopen("Tbl_text_EBU1.c", "rb");
        if(fRead == NULL)
        {
            printf("open Tbl_text_EBU1.c faild");
            getchar();
            return;
        }
        ch = fgetc(fRead);
        switch(ch)
        {
            case 0xFF:
                CodeType = TYPE_UNICODE;
                fWrite = fopen("utf_16.c", "wb");
                if(fWrite == NULL)
                    return;
                fputc(ch, fWrite);
                ch = fgetc(fRead);
                fputc(ch, fWrite);
                break;
            case 0xFE:
                CodeType = TYPE_UNICODE_BIG;
                fWrite = fopen("utf_16_Big.c", "wb");
                if(fWrite == NULL)
                    return;
                fputc(ch, fWrite);
                ch = fgetc(fRead);
                fputc(ch, fWrite);
                break;
            case 0xEF:
                CodeType = TYPE_UTF_8;
                fWrite = fopen("utf_8.c", "wb");
                if(fWrite == NULL)
                    return;
                fputc(ch, fWrite);
                ch = fgetc(fRead);
                fputc(ch, fWrite);
                ch = fgetc(fRead);
                fputc(ch, fWrite);
                break;
            default:
                return;
        }
        while(!feof(fRead))
        {
            int i;
            TempBuf[0] = fgetc(fRead);
            if(TempBuf[0] == 0xFF)
                break;
            if(CodeType == TYPE_UTF_8 && (TempBuf[0] & 0x80) == 0)
            {
                if(PutHex8(TempBuf[0], 3, &Flag))
                {
                    Flag = 0;
                    fputc(TempBuf[0], fWrite);
                }
            }
            else
            {
                TempBuf[1] = fgetc(fRead);
                //printf("\n0x%02x%02x",TempBuf[0],TempBuf[1]);
                for(i = 0; i < 256; i++)
                {
                    if(CodeType == TYPE_UTF_8)
                    {
                        if((TempBuf[0] * 256 + TempBuf[1]) == Utf8_Table[i])
                        {
                            if(i == 0xA9)
                                fgetc(fRead);// three byte//â‚¬
                            if(PutHex8(i, CodeType, &Flag))
                                i = 256;
                            break;
                        }
                    }
                    else if((TempBuf[0] * 256 + TempBuf[1]) == EBULatinBased2UnicodeTable[i] && CodeType == TYPE_UNICODE_BIG)
                    {
                        //Encode unicode
                        if(PutHex8(i, CodeType, &Flag))
                            i = 256;
                        break;
                    }
                    else if((TempBuf[1] * 256 + TempBuf[0]) == EBULatinBased2UnicodeTable[i] && CodeType == TYPE_UNICODE)
                    {
                        // Encode unicode big endian
                        if(PutHex8(i, CodeType, &Flag))
                            i = 256;
                        break;
                    }
                }
                if(i >= 256)
                {
                    Flag = 0;
                    fputc(TempBuf[0], fWrite);
                    fputc(TempBuf[1], fWrite);
                }
            }
        }

     if(fRead != NULL)
        fclose(fRead);
    if(fWrite != NULL)
        fclose(fWrite);
    return 0;
}
